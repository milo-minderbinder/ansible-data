{#
# vi: filetype=vim
#}
set nocompatible
filetype off

" set the runtime path to include Vundle and initialize
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()
" alternatively, pass a path where Vundle should install plugins
" call vundle#begin('~/some/path/here')

" let Vundle manage Vundle, required
Plugin 'VundleVim/Vundle.vim'

{% if vim_installed_version is version('8.0.0', '>=') %}
" autocompletion
Plugin 'ycm-core/YouCompleteMe'
let g:ycm_autoclose_preview_window_after_completion=1
{% endif %}

" Go language support
Plugin 'fatih/vim-go'

" Python virtualenv support within Vim (and Vim plugins - works with
" YouCompleteMe)
"Plugin 'jmcantrell/vim-virtualenv'

" Git wrapper
Plugin 'tpope/vim-fugitive'

" Gutter indicators for lines added, modified, and removed to git index
Plugin 'airblade/vim-gitgutter'

" Filesystem tree explorer
Plugin 'preservim/nerdtree'
let NERDTreeIgnore=['__pycache__$[[dir]]', '\.pyc$[[file]]'{{ ", '\~$', '\.DS_Store$[[file]]'" if ansible_os_family == 'Darwin' else "" }}]
let NERDTreeCascadeSingleChildDir=1
let NERDTreeMinimalUI=1

" NERDTree plugin to show git status indicators
Plugin 'Xuyuanp/nerdtree-git-plugin'

" Recursively diff two directories
Plugin 'will133/vim-dirdiff'

" Full path fuzzy file, buffer, mru, tag, ... finder
Plugin 'ctrlpvim/ctrlp.vim'
let g:ctrlp_root_markers=['pom.xml', 'build.gradle', 'package.json', 'Pipfile']
let g:ctrlp_regexp=1

" Code commenting utilities/bindings
"Plugin 'preservim/nerdcommenter'
Plugin 'tpope/vim-commentary'

" B-e-a-utiful colorscheme for Vim
Plugin 'altercation/vim-colors-solarized'

" Status bar/tabline for Vim (integrates with many plugins including
" virtualenv, fugitive, ctrlp, and nerdtree)
Plugin 'vim-airline/vim-airline'

" Themes/colorschemes for vim-airline
Plugin 'vim-airline/vim-airline-themes'

" Syntax, matchit, movements, & other feature support for working with
" mustache and handlebars templates
Plugin 'mustache/vim-mustache-handlebars'

" Syntax for Ansible 2.0, supporting YAML playbooks, Jinja2 templates,
" and Ansible's hosts files
Plugin 'pearofducks/ansible-vim'

" Syntax for PowerShell
Plugin 'PProvost/vim-ps1'

" All of your Plugins must be added before the following line
call vundle#end()			 " required
filetype plugin indent on	 " required
" To ignore plugin indent changes, instead use:
"filetype plugin on
"
" Brief help
" :PluginList			- list configured plugins
" :PluginInstall(!)		- install (update) plugins
" :PluginSearch(!) foo	- search (or refresh cache first) for foo
" :PluginClean(!)		- confirm (or auto-approve) removal of unused plugins
"
" see :h vundle for more details or wiki for FAQ
" Put your non-Plugin stuff after this line

" Standard configuration options follow
let mapleader=','
let g:airline_powerline_fonts=1
syntax on
if has("gui_running")
	colorscheme solarized
endif

" Options (sections and order taken from :options)
"  1 important
"  2 moving around, searching and patterns
set noautochdir
"  3 tags
"  4 displaying text
set number
if has("gui_running")
	set columns=999 lines=999
	nnoremap <leader>M :set columns=999 lines=999<CR>
endif
"  5 syntax, highlighting and spelling
set background=dark
set hlsearch
set cursorline
"  6 multiple windows
set splitbelow
set splitright
"  7 multiple tab pages
"  8 terminal
"  9 using the mouse
" 10 GUI
set guifont=Source\ Code\ Pro\ for\ Powerline:h15
set guioptions+=k
set macmeta
" 11 printing
" 12 messages and info
set showcmd
set noerrorbells
set novisualbell
set t_vb=
" 13 selecting text
" 14 editing text
" 15 tabs and indenting
" set tabstop=4
" set shiftwidth=4
" set softtabstop=0
" set noexpandtab
set autoindent
" 16 folding
" 17 diff mode
set diffopt=filler,vertical
" 18 mapping
" 19 reading and writing files
" 20 the swap file
" 21 command line editing
" 22 executing external commands
" 23 running make and jumping to errors (quickfix)
set makeprg=gmake
" 24 language specific
" 25 multi-byte characters
set encoding=utf-8
" 26 various

" Custom functions
function GetVisualSelection() abort
	if mode() ==# 'n'
		normal gv
	endif
	let [line_start, column_start]	= getpos("v")[1:2]
	let [line_end, column_end]	= getpos(".")[1:2]
	if line_start > line_end
		let [line_start, column_start, line_end, column_end] =
					\ [line_end, column_end, line_start, column_start]
	elseif line_start == line_end && column_start > column_end
		let [column_start, column_end] =
					\ [column_end, column_start]
	endif
	let lines = getline(line_start, line_end)
	let mode = mode()
	if mode ==# 'v'
		" Must trim the end before the start, the beginning will shift left.
		let lines[-1] = lines[-1][: column_end - (&selection == 'inclusive' ? 1 : 2)]
		let lines[0] = lines[0][column_start - 1:]
	elseif	mode ==# 'V'
		" Line mode no need to trim start or end
	elseif	mode == "\<c-v>"
		" Block mode, trim every line
		let new_lines = []
		let i = 0
		for line in lines
			let lines[i] = line[column_start - 1: column_end - (&selection == 'inclusive' ? 1 : 2)]
			let i = i + 1
		endfor
	else
		return ''
	endif
	" echom lines
	return lines
endfunction

function ShowVisualSelection() abort
	let initial_bufnr = bufnr()
	let visual_selection=GetVisualSelection()
	new
	let new_bufnr = bufnr()
	1put! =visual_selection
	normal! jddgg
	" execute 'resize' line('$', win_getid())
	execute 'resize' min([len(visual_selection), winheight(0)])
	setlocal buftype=nofile bufhidden=delete noswapfile winfixheight
	let &l:filetype = getbufvar(initial_bufnr, '&filetype')
	return new_bufnr
endfunction
command -range=% ShowVisualSelection call ShowVisualSelection()

{% if vim_installed_version is version('8.0.0', '>=') %}
function TermUpdateSize(expr = '') abort
	if a:expr != ''
		let bufnr = bufnr(a:expr)
	else
		let bufnr = bufnr()
	endif
	if index(term_list(), bufnr) == -1
		echoerr 'buffer' bufnr 'is not a terminal buffer!'
		return -1
	endif
	let winid = bufwinid(bufnr)
	let tabnr = win_id2tabwin(winid)[0]
	" echom 'start status, win, term, lines: ' join([term_getstatus(bufnr), winheight(winid), term_getsize(bufnr)[0], line('$', winid)])
	" let orig_height = term_getsize(bufnr)[0]
	let orig_height = winheight(winid)
	let height = orig_height
	if stridx(term_getstatus(bufnr), "finished") != -1
		" if terminal job is finished, shrink the window if taller than its output and fix its height
		let height = min([height, line('$', winid)])
		" echom 'setting fixed height for finished terminal buffer' bufnr 'from' orig_height 'to' height
		" call term_setsize(bufnr, height, 0)
		call win_execute(winid, 'resize '.height)
		call settabwinvar(tabnr, winid, '&winfixheight', 1)
	else
		let height = max([10, min([height, line('$', winid)])])
		" echom 'setting height for running terminal buffer' bufnr 'from' orig_height 'to' height
		" call term_setsize(bufnr, height, 0)
		call win_execute(winid, 'resize '.height)
	endif
	" echom 'end status, win, term, lines: ' join([term_getstatus(bufnr), winheight(winid), term_getsize(bufnr)[0], line('$', winid)])
	return {
				\'tabnr': tabnr,
				\'winid': winid,
				\'bufnr': bufnr,
				\'orig_height': orig_height,
				\'height': height,
				\}
endfunction

function UpdateAllTermSizes() abort
	for term_buf in term_list()
		call TermUpdateSize(term_buf)
	endfor
endfunction

" function MyJobCB(job, exit_status)
" 	echom 'finished: '.a:job.' '.a:exit_status
" 	echom 'buffer '.bufnr()
" endfunction

function ExecuteVisualSelection() abort
	let command_bufnr = ShowVisualSelection()
	let term_opts = {
				\"norestore": 1,
				\"hidden": 1,
				\"term_finish": "open",
				\"term_opencmd": "sbuffer %d | setlocal bufhidden=delete | call TermUpdateSize()",
				\"in_io": "buffer",
				\"in_buf": command_bufnr,
				\}
				" \"exit_cb": function('MyJobCB'),
	let output_bufnr = term_start([&shell], term_opts)
	" %terminal ++noclose
	" setlocal bufhidden=delete
	" let output_bufnr = bufnr()
	" call TermUpdateSize(output_bufnr)
	execute 'au BufWinLeave <buffer='.command_bufnr.'> bdelete' output_bufnr
	execute 'au BufWinLeave <buffer='.output_bufnr.'> bdelete' command_bufnr
	return output_bufnr
endfunction
command -range=% ExecuteVisualSelection call ExecuteVisualSelection()

" Run macro on each line in visual selection
function ExecuteMacroOverVisualRange()
	echo "@".getcmdline()
	execute ":'<,'>normal @".nr2char(getchar())
endfunction

" Handles returning to terminal mode from normal mode entered through
" EnterNormalMode()
function ExitNormalMode()
	unmap <buffer> <C-ScrollWheelDown>
	call feedkeys("a")
endfunction

" Handle entering normal mode from terminal mode, and maps CTRL+SCROLL-DOWN
" to return to terminal mode
function EnterNormalMode()
	if &buftype == 'terminal' && mode('') == 't'
		call feedkeys("\<C-W>N")
		call feedkeys("\<C-Y>")
		noremap <buffer> <C-ScrollWheelDown> :call ExitNormalMode()<CR>
	endif
endfunction
{% endif %}
function AnsibleVault(action) abort
	let AnsibleVault_path = get(g:, 'AnsibleVault_path', 'ansible-vault')
	let lines = GetVisualSelection()
	if a:action == "e"
		let modlines = systemlist("sed -E -e 's/\\\\$//' | ".AnsibleVault_path."-vault encrypt_string", lines)
	elseif a:action == "d"
		" Remove the first '!vault |' line
		let anchor_match = match(lines[0], '!vault |')
		let anchor = ""
		if anchor_match != -1
			if anchor_match > 0
				let anchor = lines[0][:anchor_match - 1]
			endif
			let lines = lines[1:]
		endif
		let modlines = systemlist("sed -E -e 's/[[:space:]]*//' -e 's/\\\\$//' | ".AnsibleVault_path." decrypt", lines)
		let modlines[0] = anchor . modlines[0]
	endif
	normal! gv"_x
	silent put =modlines
	normal! gvJ
endfunction
command -nargs=1 -range=% AnsibleVault :call AnsibleVault(<f-args>)

{% if ansible_os_family == 'Darwin' %}
function Pygmentize(lexer = &filetype) range
	" echom "running pygmentize"
	let commit = systemlist("git rev-parse --short HEAD 2>/dev/null || true")[0]
	" echom "commit: ".commit
	" make sure to generate in the correct format
	exec a:firstline.','.a:lastline.'!pygmentize -f html -o ~/tmp.html -O filename="'.expand("%").'@'.commit.'",full,linenos=table,lineseparator="<br/>",linenostart='.a:firstline.' -l '.a:lexer
	normal! u
endfunction
command -nargs=? -range=% Pygmentize :<line1>,<line2>call Pygmentize(<f-args>)
{% endif %}

function HTMLize() range
	exec a:firstline.','.a:lastline.'TOhtml'
	saveas! ~/tmp.html
	bdelete
	!open ~/tmp.html
endfunction
command -range=% HTMLize <line1>,<line2>call HTMLize()

" Custom commands
command ShowUnsavedChanges w !diff % -
command -nargs=* -complete=shellcmd R new | setlocal buftype=nofile bufhidden=hide noswapfile | 0r !<args>
command -nargs=* -range=% -complete=shellcmd WR call ShowVisualSelection() | silent %!<args>
command -nargs=+ -complete=command C let s:c_output=execute(<q-args>) |
			\ new | setlocal buftype=nofile bufhidden=hide noswapfile |
			\ 1put! =s:c_output |
			\ unlet s:c_output |
			\ normal! gg
command -nargs=1 SetSTS :set tabstop=<args> | set softtabstop=<args> | set shiftwidth=<args>
command MarkLocation :let @f=expand('%:p') . '(' . line('.') . ')'
command MakeFinding :let @f=expand('%:p') . '(' . line('.') . '):' . "\n" . getline('.')
command -range=% JSONFormat :<line1>,<line2>!python3 -m json.tool
command -range=% XMLFormat :<line1>,<line2>!cat | XMLLINT_INDENT=$'\t' xmllint --format -
" command -range=% CertText :<line1>,<line2>w !cat|sed -E s/^[[:space:]]*//|openssl x509 -text -noout|less
command -range=% CertText WR sed -E s/^[[:space:]]*// | openssl x509 -text -noout

" Custom autocommands
augroup vimrc
	au!
	" Configure indent folding with manual folds
	au BufReadPre * setlocal foldmethod=indent
	au BufWinEnter * if &fdm == 'indent' |
				\ :normal! zR<CR> |
				\ endif
	" Change the window-local current directory to the directory of the current
	" file, except when the file is in /tmp
	au BufEnter * if expand("%:p:h") !~ '^/tmp' | silent! lcd %:p:h | endif
	au TerminalWinOpen * call TermUpdateSize()
augroup END
" autocmd! GUIEnter * set vb t_vb=

" Custom keymappings
noremap <leader>m <Cmd>echom mode(1)<CR>
xnoremap <leader>v <Cmd>ShowVisualSelection<CR>
{% if vim_installed_version is version('8.0.0', '>=') %}
xnoremap <leader>e <Cmd>ExecuteVisualSelection<CR>
{% endif %}
xnoremap <leader>p :WR<Space>
nmap <leader>cc gcc
xmap <leader>cc gc

xnoremap @ :<C-u>call ExecuteMacroOverVisualRange()<CR>

{% if vim_installed_version is version('8.0.0', '>=') %}
tnoremap <C-ScrollWheelUp> <C-W>:call EnterNormalMode()<CR>
{% endif %}

nnoremap <leader>d :YcmCompleter GoToDeclaration<CR>
nnoremap <leader>i :YcmCompleter GoToDefinition<CR>
nnoremap <leader>k :YcmCompleter GetDoc<CR>

nnoremap <C-N> :NERDTreeToggle<CR>

nnoremap <leader>b Oimport pdb; pdb.set_trace()<ESC>
nnoremap <leader>B Oimport ipdb; ipdb.set_trace()<ESC>
nnoremap <leader>C /^[<>\|=]\{7\}<CR>
nnoremap <leader>l :MarkLocation<CR>
nnoremap <leader>f :MakeFinding<CR>
nnoremap <leader>F "fp
nnoremap <leader>n :noh<CR>
nnoremap <leader>s /\s\+$<CR>
nnoremap <leader>D :q<CR>:diffoff<CR>
"xnoremap // y:call setreg('9', escape(@", '\\/.*$^~[]'))<cr>/<c-r>9<cr>
xnoremap // y:call setreg('9', substitute(substitute(escape(@", '\\/.*$^~[]'), '\n', '\\n', 'g'), '\r', '\\r', 'g'))<cr>/<c-r>9<cr>

{% if ansible_os_family == 'Darwin' %}
" Map <leader>o to <C-w>F -> Opens file under cursor to line:
nnoremap <leader>o F
" Map <leader>O to <C-w>gF -> Opens file under cursor to line in a new tab:
nnoremap <leader>O gF
{% else %}
" Map <Alt-o> to <C-w>F -> Opens file under cursor to line:
nnoremap ï F
" Map <Alt-O> to <C-w>gF -> Opens file under cursor to line in a new tab:
nnoremap Ï gF
{% endif %}
